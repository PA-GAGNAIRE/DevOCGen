// Build a biogeographical model using 
// a homogeneous spatial map
// a dispersion following a Normal distribution 
// a population with no particular life cycle

initialize() {
	initializeSLiMModelType("nonWF"); // non Wrigth Fisher
	initializeSLiMOptions(dimensionality="xy"); // 2D model 
	initializeTreeSeq(retainCoalescentOnly=T);	// record tree-sequence 
	
	initializeMutationRate(0.0); // no mutations simulated 
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 1e7); // length of simulated chrosmosome 
	initializeRecombinationRate(1e-8); // recombination rate per base 
	
	defineConstant("W", 100.0); // spatial map width 
	defineConstant("K", 3);	// local carrying capacity
	defineConstant("S_compet", 1.0); // spatial competition width 
	defineConstant("S_mate", 1.0); // spatial mate choice width 
	defineConstant("S_disp", 1.0); // dispersal width 
	defineConstant("LAMBDA", 1.5); // mean number of offspring
	defineConstant("spatial", "hetero_N"); // type of spatial map
	
	// spatial competition
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=3*S_compet); // only individuals within distance 3*sigma  
	i1.setInteractionFunction("n", 1.0/(2*PI*S_compet^2), S_compet); // convert into interaction strength using a Gaussian
	
	// spatial mate choice
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=3*S_mate); // only individuals within distance 3*sigma
	i2.setInteractionFunction("n", 1.0/(2*PI*S_mate^2), S_mate); // convert into interaction strength using a Gaussian 
}


// mate choice 
reproduction(){
	pos = individual.spatialPosition; 
	map_val = p1.spatialMapValue("MAP", pos);
	if (map_val < 0.25)
    	K_local = 0.5;
	else if (map_val < 0.5)
   	 K_local = 1.0;
	else if (map_val < 0.75)
   	 K_local = 2.0;
	else
  	  K_local = K;
	neighbor_density = i1.totalOfNeighborStrengths(individual) ; // sum of interaction strengths 
	num_offspring = rpois(1, LAMBDA / (1 + neighbor_density / K_local)); 
	for (i in seqLen(num_offspring)) { 
		mate = i2.drawByStrength(individual, 1); // choose our nearest neighbor as a mate, within the max distance
			if (size(mate) > 0) { // if there is a mate (possible none within interacting distance, in which case there no offspring)
			offspring = p1.addCrossed(individual, mate); // make offspring by sexual reproduction 
			pos = individual.spatialPosition + rnorm(2, 0, S_disp); // set position of offspring as random normal in both directions 
		
			// reprising boundary
			if (p1.spatialMapValue("MAP", pos) != 0.0 & p1.pointInBounds(pos)){
			offspring.setSpatialPosition(pos); }
			else {}
			}
	}
}

// initiate population 
1 early() {
	sim.addSubpop("p1", asInteger(round(K*W*W))); // set population size at carrying capacity
	
	p1.setSpatialBounds(c(0.0, 0.0, W, W));
	
	// laod the black and white map file generated with the R script
	mapImage = Image("./SLiM/map_100x100_hetero_grayscale.png");
	p1.defineSpatialMap("MAP", "xy", mapImage.floatK,
		valueRange=c(0.0, 1.0), colors=c("#CCCCCC","#0000CC"));
	
	// initialize individual spatial positions 
	inds = p1.individuals;
	for (i in seqLen(size(inds))) {
    pos = NULL;
    while (isNULL(pos)) {
        candidate = c(runif(1, 0, W), runif(1, 0, W));
        if (p1.spatialMapValue("MAP", candidate) != 0.0) {
            pos = candidate;
        }
    }
    inds[i].setSpatialPosition(pos);
}
}

// survival probabilities 
early() {
	inds = p1.individuals; 
	inds[inds.age > 0].fitnessScaling = 0.0; // remove adults to make discrete generations 
}

late() {
	// evaluate mate choice and competition in preparation for reproduction
	i1.evaluate(p1); // competition
	i2.evaluate(p1); // look for mate
}

5000 late() {	
	sim.treeSeqOutput("./Tree_Sequence/" + "forw_" + spatial + "_m" + S_disp + "_N" + K + ".trees"); //save the tree sequence with a special name
	sim.simulationFinished(); 	
}
