// Build a biogeographical model using 
// a homogeneous spatial map
// a dispersion following a Normal distribution 
// a population with no particular life cycle

initialize() {
	initializeSLiMModelType("nonWF"); // non Wrigth Fisher
	initializeSLiMOptions(dimensionality="xy"); // 2D model 
	initializeTreeSeq(retainCoalescentOnly=F);	// record tree-sequence 
	
	initializeMutationRate(0.0); // no mutations simulated 
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1.0);
	initializeGenomicElement(g1, 0, 1e8); // length of simulated chrosmosome 
	initializeRecombinationRate(1e-8); // recombination rate per base 
	
	defineConstant("W", 100.0); // spatial map width 
	defineConstant("K", 1.0);	// local carrying capacity
	defineConstant("S_compet", 1.0); // spatial competition width 
	defineConstant("S_mate", 1.0); // spatial mate choice width 
	defineConstant("S_disp", 50.0); // maximal dispersal width
	defineConstant("LAMBDA", 2.0); // mean number of offspring
	defineConstant("MAXt", 40000); // number of gens to run to attend the expected time to an MRCA
	defineConstant("rep", 1); // number of replicats
	defineConstant("spatial", "hetero_m"); // type of spatial map
	defineConstant("model", "theo");  // type of simulations
	
	// spatial competition
	initializeInteractionType(1, "xy", reciprocal=T, maxDistance=3*S_compet); // only individuals within distance 3*sigma  
	i1.setInteractionFunction("n", 1.0/(2*PI*S_compet^2), S_compet); // convert into interaction strength using a Gaussian
	
	// spatial mate choice
	initializeInteractionType(2, "xy", reciprocal=T, maxDistance=3*S_mate); // only individuals within distance 3*sigma
	i2.setInteractionFunction("n", 1.0/(2*PI*S_mate^2), S_mate); // convert into interaction strength using a Gaussian 
}

// mate choice 
reproduction(){
	file = "/mnt/DATA1/OUTPUT_SLIM/disp_by_mapval_" + "forw" + "_homo" + "_m" + S_disp + "_N" + K + "_" + model + "_rep" + rep + ".txt"; // create a file for save disp by map value 
	neighbor_density = i1.totalOfNeighborStrengths(individual) ; // sum of interaction strengths 
	num_offspring = rpois(1, LAMBDA / (1 + neighbor_density / K)); 
	for (i in seqLen(num_offspring)) { 
		mate = i2.drawByStrength(individual, 1); // choose our nearest neighbor as a mate, within the max distance
		if (size(mate) > 0) { // if there is a mate (possible none within interacting distance, in which case there no offspring)
			offspring = p1.addCrossed(individual, mate); // make offspring by sexual reproduction 
			
			map_val = p1.spatialMapValue("MAP", individual.spatialPosition); // record map value for each individual spatial position
			if (map_val < 0.25)
    			S_disp_local = 1.0;
			else if (map_val < 0.5)
    			S_disp_local = 10.0;
			else if (map_val < 0.75)
    			S_disp_local = 25.0;
			else
    			S_disp_local = S_disp;
			pos = individual.spatialPosition + rnorm(2, 0, S_disp_local); // set position of offspring as random normal in both directions 
		
			// reprising boundary
			if (p1.spatialMapValue("MAP", pos) != 0.0 & p1.pointInBounds(pos)){
				offspring.setSpatialPosition(pos); 
			
				dist = sqrt((pos[0] - individual.spatialPosition[0])^2 + (pos[1] - individual.spatialPosition[1])^2);
   			writeFile(file, paste(map_val, dist, sep="\t"), append = T);}
			else {}
		}
	}
}

// initiate population 
1 early() {
	sim.addSubpop("p1", asInteger(round(K*W*W))); // set population size at carrying capacity
	
	p1.setSpatialBounds(c(0.0, 0.0, W, W));
	
	// laod the black and white map file generated with the R script
	mapImage = Image("/mnt/DATA1/MAP/map_100x100_hetero_grayscale.png");
	p1.defineSpatialMap("MAP", "xy", mapImage.floatK,
		valueRange=c(0.0, 1.0), colors=c("#CCCCCC","#0000CC"));
	
	// initialize individual spatial positions 
	inds = p1.individuals;
	for (i in seqLen(size(inds))) {
    pos = NULL;
    while (isNULL(pos)) {
        candidate = c(runif(1, 0, W), runif(1, 0, W));
        if (p1.spatialMapValue("MAP", candidate) != 0.0) {
            pos = candidate;}
    }
    inds[i].setSpatialPosition(pos);
	}
}

// survival probabilities 
early() {
	inds = p1.individuals; 
	inds[inds.age > 0].fitnessScaling = 0.0; // remove adults to make discrete generations 
}
	
late() {
	// evaluate mate choice and competition in preparation for reproduction
	i1.evaluate(p1); // competition
	i2.evaluate(p1); // look for mate
	sim.treeSeqRememberIndividuals(p1.individuals, permanent=F); //remember individuals only if ancestors of final population
}

(MAXt) late() {
	sim.simulationFinished(); 
	
	// save the tree sequence with a special name
	sim.treeSeqOutput("/mnt/DATA1/TS/" + "forw_" + spatial + "_m" + S_disp + "_N" + K + "_" + model + "_rep" + rep + ".trees"); 
}
